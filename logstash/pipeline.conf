# Logstash Pipeline Configuration for Application Logs
# ECS-compliant with conditional routing

input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # Parse JSON from the message field
  json {
    source => "message"
    target => "app_data"
    skip_on_invalid_json => true
  }

  # Only process if JSON parsing was successful
  if [app_data] {
    
    # Parse timestamp and set @timestamp
    if [app_data][ts] {
      date {
        match => [ "[app_data][ts]", "ISO8601" ]
        target => "@timestamp"
      }
    }

    # Map application fields to ECS-compliant fields
    if [app_data][svc] {
      mutate {
        add_field => { "[service][name]" => "%{[app_data][svc]}" }
      }
    }

    # Map log level to ECS log.level
    if [app_data][lvl] {
      mutate {
        add_field => { "[log][level]" => "%{[app_data][lvl]}" }
        lowercase => [ "[log][level]" ]
      }
    }

    # Map message field
    if [app_data][msg] {
      mutate {
        add_field => { "message_parsed" => "%{[app_data][msg]}" }
      }
    }

    # Map user field to ECS user.id
    if [app_data][user] {
      mutate {
        add_field => { "[user][id]" => "%{[app_data][user]}" }
      }
    }

    # Convert latency_ms to event.duration in nanoseconds
    if [app_data][latency_ms] {
      ruby {
        code => "
          latency_ms = event.get('[app_data][latency_ms]')
          if latency_ms.is_a?(Numeric)
            event.set('[event][duration]', latency_ms * 1_000_000)
          end
        "
      }
      
      # Also keep the original latency in a more accessible field
      mutate {
        add_field => { "[performance][response_time_ms]" => "%{[app_data][latency_ms]}" }
        convert => { "[performance][response_time_ms]" => "integer" }
      }
    }

    # Set event.dataset for better categorization
    mutate {
      add_field => { 
        "[event][dataset]" => "application.logs"
        "[event][category]" => "application"
        "[event][type]" => "info"
      }
    }

    # Override event.type for errors
    if [log][level] == "error" {
      mutate {
        replace => { "[event][type]" => "error" }
      }
    }

    # Add labels for better filtering/aggregation
    if [service][name] {
      mutate {
        add_field => { "[labels][service]" => "%{[service][name]}" }
      }
    }

    # Clean up: remove the temporary app_data object to avoid field explosion
    mutate {
      remove_field => [ "app_data" ]
    }

    # Set routing tags based on log level
    if [log][level] == "error" {
      mutate {
        add_tag => [ "route_to_error_index" ]
      }
    } else {
      mutate {
        add_tag => [ "route_to_default_index" ]
      }
    }
  }
  
  # If JSON parsing failed, tag for dead letter queue
  else {
    mutate {
      add_tag => [ "json_parse_failure", "_grokparsefailure" ]
    }
  }

  # Add common ECS fields
  mutate {
    add_field => { 
      "[ecs][version]" => "8.0"
      "[agent][name]" => "logstash"
      "[agent][type]" => "logstash"
    }
  }
}

output {
  # Route to error index for error-level logs
  if "route_to_error_index" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "logs-app-error-%{+YYYY.MM.dd}"
      
      # Template management - pointing to external template file
      manage_template => true
      template_name => "logs-app-error"
      template => "/usr/share/logstash/templates/logs-app-error-template.json"
      template_overwrite => true
    }
  }
  
  # Route to default index for non-error logs
  else if "route_to_default_index" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "logs-app-default-%{+YYYY.MM.dd}"
      
      # Template management - pointing to external template file
      manage_template => true
      template_name => "logs-app-default"
      template => "/usr/share/logstash/templates/logs-app-default-template.json"
      template_overwrite => true
    }
  }
  
  # Dead letter queue for failed parsing
  else {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "logs-app-failed-%{+YYYY.MM.dd}"
    }
  }

  # Debug output (remove in production)
  stdout { 
    codec => rubydebug 
  }
}